# 2098

import sys
input = sys.stdin.readline
INF = int(1e9)

n = int(input())    # 도시의 개수
w = []      # w[i][j]: i -> j로 가는 데 드는 비용 저장 리스트

for _ in range(n):
    w.append(list(map(int, input().split())))

# d[c][v]: 현재도시가 c, 현재까지 방문한 모든 도시 리스트가 v일 때 남은 모든 도시를 경유하는 데 필요한 최소 비용
d = [[0] * (1 << 16) for _ in range(16)]

def tsp(c, v):  # 완전 탐색의 형태로 수행
    if v == (1 << n) - 1:   # 모든 노드를 방문한 경우
        # 시작 도시로 돌아갈 수 없을 때
        if w[c][0] == 0:
            return INF      # 무한 
        # 시작 도시로 돌아갈 수 있을 때
        else:
            return w[c][0]      # w[c][시작 도시]
    if d[c][v] != 0:    # 이미 방문한 노드인 경우
        return d[c][v]
    
    min_val = INF
    for i in range(n):
        # 방문한 적이 없고, 갈 수 있는 도시인 경우
        if (v & (1 << i)) == 0 and w[c][i] != 0:
            min_val = min(min_val, tsp(i, (v | (1 << i))) + w[c][i])
    d[c][v] = min_val
    return d[c][v]

# 도시를 순회하는 것 이므로 어떤 도시에서 출발해도 상관 X
print(tsp(0, 1))


"""
모든 도시 순회 판단 연산식
if (v == (1 << N) - 1)
ex) N = 4(도시개수): (1 << 4) - 1 = 16 - 1 = 15
-> 15를 이진수로 표현: 1111 -> 모든 도시를 방문한 상태(방문:1, 미방문: 0)

방문 도시 확인 연산식
if ((v & (1 << i)) == 0)
ex) i = 3(4번째 도시 확인 여부 확인): 1 << 3 = 8 = 100(이진수)
-> v & 1000 연산을 수행했을 때 결과값이 0이면 4번째 도시를 방문하지 않았다고 판단
    즉, v의 이진수 표현시 4번째 자리가 1이 아닌경우 0을 리턴하면 4번째 도시를 방문하지 않았다고 판단

방문 도시 저장 연산식
v | (1 << i)
ex) i = 2(3번째 도시 저장): 1 << 2 = 100(이진수)
-> v | 100 연산을 수행하면 v의 이진수 표현시 3번째 자리를 1로 저장하게 되어 3번째 도시를 방문한 사실을 저장
"""