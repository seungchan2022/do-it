# 1931

n = int(input())
time = []

for _ in range(n):
    start, end = map(int, input().split())
    time.append((start, end))

time = sorted(time, key=lambda x: x[0])     # 시작 시간을 기준으로 오름차순 정렬
time = sorted(time, key=lambda x: x[1])     # 끝나는 시간을 기준으로 다시 오름차순 정렬

last = 0    # 회의의 마지막 시간을 저장할 변수
count = 0   # 회의 개수를 저장할 변수

for i, j in time:   # (시작시간, 끝나는 시간)
    if i >= last:   # 시작시간이 회의의 마지막 시간보다 크거나 같으면
        count += 1
        last = j

print(count)


"""
주어진 시작시간과 끝나는 시간들을 이용해서 가장 많은 회의의 수를 알기 위해서는 빨리 끝나는 회의 순서대로 정렬를 해야 한다.
빨리 시작하는 순서대로 정렬을 우선시 한다면, 오히려 늦게 끝날수 있기 때문이다.

그래서 먼저 시작시간을 오름차순으로 정렬한뒤, 끝나는 시간을 기준으로 한번 더 정렬을 해야 한다.
이미 시작시간이 오름차순으로 정렬된 상태이므로 끝나는 시간으로 오름차순을 해주어도 끝나는 시간이 같을 떄에는 시작시간의 오름차순으로 정렬 되어 있다.

정렬된 이후에 시작시간과 끝나는 시간을 비교한다.
마지막 회의 시간을 저장할 변수 last와 회의의 수 count를 선언한후,
시작시간과 last를 비교하여 시작시간이 last보다 크거나 같으면 count +1 하고 last변수에 회의 마지막 시간 대입한다
"""